package edu.gemini.spModel.obsseq;

import edu.gemini.spModel.config2.Config;
import edu.gemini.spModel.config2.ItemKey;
import edu.gemini.spModel.config2.ItemEntry;
import edu.gemini.spModel.config2.DefaultConfig;

import java.util.*;

/**
 * Provides a simple ConfigProducer implementation based upon a List of
 * {@link Config} changes.  The list contains the items that should be
 * modified in each step.
 *
 * <p>This class is <em>not</em> MT safe.  Concurrent access by multiple
 * threads must be synchronized.
 */
public class DefaultConfigProducer implements ConfigProducer {

    /**
     * The {@link ConfigMerger} implementation used with
     * {@link DefaultConfigMerger}.  It steps through the list of
     * configs.
     */
    public class DefaultConfigMerger implements ConfigMerger {
        private int _step;

        public boolean hasNextConfig() {
            return _step < _configs.size();
        }

        public void mergeNextConfig(Config config) {
            config.putAll(_configs.get(_step++));
        }
    }

    private List<Config> _configs = new ArrayList<>();

    /**
     * Constructs with an empty list of {@link Config}.
     */
    public DefaultConfigProducer() {
    }

    /**
     * Constructs with the given {@link Config}s, in the given order.
     *
     * @param configs configurations that should form the initial set of
     * {@link Config} for this producer
     */
    public DefaultConfigProducer(Config[] configs) {
        Collections.addAll(_configs, configs);
    }

    public int getStepCount() {
        return _configs.size();
    }

    public ItemKey[] getIteratedKeys() {
        if (_configs.size() <= 1) return ItemKey.EMPTY_ARRAY;

        Config startConfig = _configs.get(0);

        Set<ItemKey> keys = new HashSet<>();
        for (int i=1; i<_configs.size(); ++i) {
            Config config = _configs.get(i);
            ItemEntry[] itemEntryArray = config.itemEntries();

            for (ItemEntry anItemEntryArray : itemEntryArray) {
                ItemKey key = anItemEntryArray.getKey();
                Object val = anItemEntryArray.getItemValue();

                if (!val.equals(startConfig.getItemValue(key))) {
                    keys.add(key);
                }
            }
        }
        return keys.toArray(ItemKey.EMPTY_ARRAY);
    }

    public ConfigMerger getConfigMerger() {
        return new DefaultConfigMerger();
    }

    /**
     * Gets all the {@link Config} objects, in the order that they would
     * be produced.
     */
    public Config[] getConfigs() {
        return _configs.toArray(DefaultConfig.EMPTY_ARRAY);
    }

    /**
     * Sets all the {@link Config} objects to be generated by this producer.
     * Any previous Configs are forgotten.  The <code>configs</code> array
     * may be subsequently modified without impacting this object, but the
     * Config objects it contains are shared (so changes to them are visible).
     *
     * @param configs to generate in the order that they should be generated
     */
    public void setConfigs(Config[] configs) {
        _configs.clear();
        Collections.addAll(_configs, configs);
    }

    /**
     * Adds the given Config to the end of the list of Configs to produce.
     * The reference to the Config is shared by this object.
     *
     * @param config configuration to add
     */
    public void addConfig(Config config) {
        _configs.add(config);
    }

    /**
     * Adds the given Config to the list of Configs to produce at the indicated
     * position.  Any elements previously at the <code>index</code> position
     * are shifted to the right (i.e., their indices are increased by one).
     * The reference to the Config is shared by this object.
     *
     * @param index where in the sequence this Config would be produced
     *
     * @param config configuration to add
     *
     * @throws IndexOutOfBoundsException if the index is out of the range
     * (0 <= index <= getStepCount())
     */
    public void addConfig(int index, Config config) {
        _configs.add(index, config);
    }

    /**
     * Removes all Configs from the ordered list of Configs.  After calling
     * this method, the {@link DefaultConfigMerger} would not produce any
     * configs.
     */
    public void clearConfigs() {
        _configs.clear();
    }

    /**
     * Removes the specified Config from the list of Configs.  Any Configs
     * that may exist after <code>config</code> are shifted to the left (i.e.,
     * one is subtracted from their indices).
     *
     * @param config configuration to remove
     *
     * @return <code>true</code> if the specified Config is removed from the
     * DefaultConfigProducer, <code>false</code> otherwise
     */
    public boolean removeConfig(Config config) {
        return _configs.remove(config);
    }

    /**
     * Removes the {@link Config} at the specified index position from the list
     * of Configs to produce.  Any Configs that may exist after the
     * <code>index</code> position are shifted to the left (i.e., one is
     * subtracted from their indices).
     *
     * @param index position at which the corresponding {@link Config} should
     * be removed
     *
     * @return {@link Config} which was previously at the <code>index</code>
     * position
     *
     * @throws IndexOutOfBoundsException if the index is out of the range
     * (0 <= index < getStepCount())
     */
    public Config removeConfig(int index) {
        return _configs.remove(index);
    }

    /**
     * Replaces the {@link Config} at the specified position in the list with
     * the specified {@link Config}.
     *
     * @param index position at which the corresponding {@link Config} should
     * be replaced
     *
     * @return {@link Config} which was previous at the <code>index</code>
     * position
     *
     * @throws IndexOutOfBoundsException if the index is out of the range
     * (0 <= index < getStepCount())
     */
    public Config setConfig(int index, Config config) {
        return _configs.set(index, config);
    }
}
